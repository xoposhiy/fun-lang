#summary Спецификация языка Fun
#labels Phase-Requirements

<wiki:toc max_depth="2" />


Программа на языке Fun — это произвольная последовательность из определений функций и вызовов встроенных или определенных ранее функций.

Грамматика языка Fun состоит из следующих правил вывода:
{{{
1. Program -> (Sentence '.') *

2. Sentence -> FunCall
3. FunCall -> NAME [ '(' FunCall* ')' ]

4. Sentence -> FunDef
5. FunDef  -> fun NAME [ '(' NAME* ')' ] FunCall
}}}

1. Программа — это последовательность предложений, каждое из которых заканчивается точкой.

= Funny =

2, 3. В качестве предложения может выступать вызов функции. Правила 1, 2, 3 определяют простейшее подмножество Funny, позволяющего лишь вычислять функции, являющиеся композицией стандартных, встроенных в язык функций.

Вот примеры корректных программ на Funny и результат выполнения каждой из программ:
{{{
+(2 2).
-> 4

=(4 +(2 2)).
-> true

if(>(+(2 2) 3) 
  1
  0
).
-> 1

42().
-> 42
}}}

Язык Funny лишён возможности инфиксной записи арифметических выражений. Вместо этого все арифметические операции представлены в виде функций. Так, '+', '=', '<' — это имена встроенных функций.

Язык Funny — это ленивый язык. Функция будет вычислена только в том случае, если ее значение понадобилось. Благодаря этому свойству, конструкцию if удалось реализовать в виде встроенной функции от трёх аргументов: булева выражения, и двух веток, которые будут вычисляться, если булево выражение соответственно истинно или ложно.

В языке Funny все есть функция. Даже константы — суть функции без параметров. 42 — это всего лишь сокращенная запись вызова константной функции `42()` (скобки у функций без аргументов можно опускать). 

= Fun =
{{{
4. Sentence -> FunDef
5. FunDef  -> fun NAME [ '(' NAME* ')' ] FunCall
}}}
Эти два правила вывода грамматики Fun говорят о том, что в качестве предложения можно использовать конструкции для определения собственных функций:

{{{
fun id(x) x.

fun inc(x) +(x 1).

fun sum(a b c) +(a +(b c)).
}}}

Язык Fun предоставляет возможность создавать рекурсивные функции:

{{{
fun fibb(n)
	if (<(n 2) 
		1
		+(fibb(-(n 1)) fibb(-(n 2)))
	).

fun fact(n) 
	if(=(n 1) 
		1 
		*(fact(-(n 1)) n)
	).
}}}

Еще раз продемонстрировать ленивость языка Fun можно определив такую функцию:
{{{
fun infinity infinity.

fun testLazy(x)
	if(>(x 0) 1 infinity).
	
testLazy(1).
-> 1
}}}

Определенную пользователем функцию можно использовать где угодно ниже определения этой функции. Таким образом такая программа будет некорректной:
{{{
one().

fun one() 1.
}}}

= Типы данных =
[DataTypes Описание типов данных.]

= Лексика =
Как видно из определения грамматики, в языке Fun есть не так много лексем:
  * скобки `(`, `)`;
  * точка `.`;
  * и произвольное имя, не содержащее в себе пробельных символов и символов, составляющих перечисленные выше лексемы.

Между лексемами может быть произвольное количество пробельных символов, которые не влияют на выполнение программы.
#summary Спецификация языка Fun
#labels Phase-Requirements

<wiki:toc max_depth="2" />

= Funny =

Программа на языке Fun — это произвольная последовательность из определений функций и вызовов встроенных или определенных ранее функций.

Грамматика языка Fun состоит всего из двух правил вывода:
{{{
FunCall -> NAME [ '(' FunCall* ')' ]
FunDef  -> fun NAME [ '(' NAME* ')' ] FunCall
}}}

Первое правило определяет простейшее подмножество Funny, позволяющего лишь вычислять функции, являющиеся композицией стандартных, встроенных в язык функций.

Вот примеры корректных программ на Funny и результат выполнения каждой из программ:
{{{
+(2 2)
-> 4

=(4 +(2 2))
-> true

if(>(+(2 2) 3) 
  1
  0
)
-> 1

42()
-> 42
}}}

Язык Funny лишён возможности инфиксной записи арифметических выражений. Вместо этого все арифметические операции представлены в виде функций. Так, '+', '=', '<' — это имена встроенных функций.

Язык Funny — это ленивый язык. Функция будет вычислена только в том случае, если ее значение понадобилось. Благодаря этому свойству, конструкцию if удалось реализовать в виде встроенной функции от трёх аргументов: булева выражения, и двух веток, которые будут вычисляться, если булево выражение соответственно истинно или ложно.

В языке Funny все есть функция. Даже константы — суть функции без параметров. 42 — это всего лишь сокращенная запись вызова константной функции `42()` (скобки у функций без аргументов можно опускать). 

= Fun =
Второе правило вывода грамматики Fun открывает возможность определять новые функции:

{{{
FunDef  -> fun NAME ['(' NAME* ')'] FunCall
}}}

Вот примеры таких определений:

{{{
fun id(x) x

fun inc(x) +(x 1)

fun sum(a b c) +(a +(b c))
}}}

Язык Fun предоставляет возможность создавать рекурсивные функции:

{{{
fun fibb(n)
	if (<(n 2) 
		1
		+(fibb(-(n 1)) fibb(-(n 2)))
	)

fun fact(n) 
	if(=(n 1) 
		1 
		*(fact(-(n 1)) n)
	)
}}}

Еще раз продемонстрировать ленивость языка Fun можно определив такую функцию:
{{{
fun infinity infinity

fun testLazy(x)
	if(>(x 0) 1 infinity)
	
testLazy(1)
-> 1
}}}

Определенную пользователем функцию можно использовать где угодно ниже определения этой функции. Таким образом такая программа будет некорректной:
{{{
one()

fun one() 1
}}}


= Типы данных =
Каждый тип данных характеризуется двумя наборами функций:
  * набором встроенных константных функций, определяющих множество допустимых значений этого типа данных, 
  * набором функций, совершающих операции над значениями данного типа.

== boolean ==
Константы: `true()` и `false()`
Операции: &, |, !, =, # (неравенство), `if` (ветвление)

== int ==
Константы: `X()`, где X — десятичная запись целого 32-битного числа. 
Операции: +, -, `*`, /, %, =, #, <, >, >=, <=.

= Лексика =
Как видно из определения грамматики, в языке Fun есть всего четыре лексемы:
  * ключевое слово `fun`;
  * скобки `(`, `)`;
  * и произвольное имя, не содержащее в себе пробельных символов.

Между лексемами может быть произвольное количество пробельных символов, которые не влияют на выполнение программы.
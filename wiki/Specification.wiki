#summary Спецификация языка Fun
#labels Phase-Requirements

<wiki:toc max_depth="2" />

Программа на языке Fun — это произвольная последовательность из определений и вызовов встроенных или определенных ранее функций.

Ниже перечисляются все правила грамматики fun с некоторыми комментариями.

Программа — это последовательность предложений.
{{{
1. Program -> Sentence * 
}}}

Предложения бывают двух видов — определение и вычисление. Все предложения оканчиваются точкой с запятой.
{{{
2. Statement ::= 'let' NAME ':=' Term ';'
3. Statement ::= Term ';'
}}}

Определение дает имя выражению, стоящему справа от знака ':='. Далее это имя может использоваться для обозначения этого выражения.

В качестве Term может использоваться имя встроенной или определенной ранее функции (в fun все является функцией, даже константы — это тоже функции).
{{{
4. Term ::= NAME
}}}

Либо вызов функции. В fun вызов функции — это самая распространенная операция, поэтому чтобы сделать синтаксис более лаконичным, скобки, окружающие список аргументов писать не нужно.
{{{
5. Term ::= Term Term
}}}
Например, "sin x" в языке fun — это корректный вызов функции sin с аргументом x.

Для целей группировки, выражения можно заключать в круглые скобки.
{{{
6. Term ::= '(' Term ')'
}}}

И, наконец, выражение может определять новую анонимную функцию. 
{{{
7. Term ::= 'fun' '(' name ')' Term
}}}
Анонимность означает, что у функции нет имени. Однако ее по прежнему можно вызывать и вообще делать с ней все, что захочется. Вот пара примеров:
{{{
doSomething (fun(x) + x x); // Передали анонимную функцию в качестве аргумента
(fun(x) + x x) 2; // Передали анонимной функции в качестве аргумента 2. 
// В результате вычисления этого выражения получится 4.
}}}


Как видно, язык fun лишён возможности инфиксной записи арифметических выражений. Вместо этого все арифметические операции представлены в виде функций. Так, '+', '=', '<' — это имена встроенных функций.

Ещё одно замечания — в языке fun есть функции только от одной переменной. Это не является серьезным ограничением, поскольку функция от нескольких переменных легко моделируется с помощью функций от одной переменной вот так:
{{{
f(x, y) = (f(x))(y)
}}}
если положить, что f(x) возвращает функцию, которую можно применить ко аргументу "y".

==Ленивые вычисления==
{{{
if (> (+ 2 2) 3) 
  1
  0;
-> 1
}}}
Язык fun — это ленивый язык. Функция будет вычислена только в том случае, если ее значение понадобилось. Благодаря этому свойству, конструкцию if удалось реализовать в виде встроенной функции от трёх аргументов: булева выражения, и двух веток, которые будут вычисляться, если булево выражение соответственно истинно или ложно.


Несколько примеров определения функций:
{{{
let id := fun(x) x;

let inc := fun(x) + x 1;

let sum := fun(a)fun(b)fun(c) + a (+ b c);
}}}

Язык fun предоставляет возможность создавать рекурсивные функции:

{{{
let fibb := fun(n)
	if (< n 2) 
		1
		(+ (fibb (-n 1)) (fibb (- n 2)))
	);

let fact := fun(n) 
	(if (= n 1) 
		1 
		(* (fact (-n 1)) n)
	);
}}}

Еще раз продемонстрировать ленивость языка Fun можно определив такую функцию:
{{{
let infinity := fun(x) infinity(x);

let testLazy := fun(x) 
	if (> x 0) 1 infinity;
	
testLazy(1);
-> 1
}}}
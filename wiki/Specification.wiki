#summary Спецификация языка Fun
#labels Phase-Requirements

<wiki:toc max_depth="2" />


Программа на языке Fun — это произвольная последовательность из определений функций и вызовов встроенных или определенных ранее функций.

Грамматика языка Fun состоит из следующих правил вывода:
{{{
1. Program -> (Sentence '.') *

2. Sentence -> FunCall
3. FunCall -> NAME ( '(' FunCall* ')' )*

4. Sentence -> FunDef
5. FunDef  -> fun NAME [ '(' NAME* ')' ] FunCall
}}}

1. Программа — это последовательность предложений, каждое из которых заканчивается точкой.

= Funny =
В качестве предложения может выступать вызов функции. Правила 1, 2, 3 определяют простейшее подмножество Funny, позволяющего лишь вычислять функции, являющиеся композицией стандартных, встроенных в язык функций.

==Функции==

{{{
42().
-> 42
}}}

В языке Funny все есть функция. Даже константы — суть функции без параметров. 42 — это всего лишь сокращенная запись вызова константной функции `42()` (скобки у функций без аргументов можно опускать). 

{{{
+(2 2).
-> 4

=(4 +(2 2)).
-> true
}}}


Язык Funny лишён возможности инфиксной записи арифметических выражений. Вместо этого все арифметические операции представлены в виде функций. Так, '+', '=', '<' — это имена встроенных функций.


==Ленивые вычисления==
{{{
if(>(+(2 2) 3) 
  1
  0
).
-> 1
}}}
Язык Funny — это ленивый язык. Функция будет вычислена только в том случае, если ее значение понадобилось. Благодаря этому свойству, конструкцию if удалось реализовать в виде встроенной функции от трёх аргументов: булева выражения, и двух веток, которые будут вычисляться, если булево выражение соответственно истинно или ложно.

== Возврат из функции неконстантной функции ==
{{{
3. FunCall -> NAME ( '(' FunCall* ')' )*
}}}
Можно заметить, что грамматика позволяет не только опускать скобки, но и ставить несколько  пар скобок после функции:
{{{
f(5)(2)
}}}
Это имеет следующий смысл: вызов `f(5)` возвращает другую функцию, которая вызывается с аргументом `2`. Вот ещё один пример использования этой возможности:
{{{
fun apply(f x y)
  f(x y).

apply(+ 1 2).
->3
}}}

==Карринг==
В языке fun допустим вызов функции, с указанием не всех ее аргументов. Рассмотрим пример:
{{{
+(2)(3)
->5
}}}
Тут `+(2)` возвращает функцию от одного аргумента, возвращающую свой аргумент, увеличенный на два.

Частичное указание аргументов функции называется _карринг_. Это операция, преобразующая одну функцию в другую функцию с меньшим количеством аргументов.

Вызов функции от нескольких аргументов эквивалентен последовательному каррингу, вот так:
{{{
if(true 1 2).
->1
if(true)(1)(2).
->1
}}}

==Побочные эффекты==
Все рассмотренные ранее функции были _чистыми_ функциями лишенными побочных эффектов. В языке есть поддержка и _грязных_ функций — функций с побочными эффектами.

[DirtyFunctions Функции с побочными эффектами].

= Fun =
{{{
4. Sentence -> FunDef
5. FunDef  -> fun NAME [ '(' NAME* ')' ] FunCall
}}}
Эти два правила вывода грамматики Fun говорят о том, что в качестве предложения можно использовать конструкции для определения собственных функций:

{{{
fun id(x) x.

fun inc(x) +(x 1).

fun sum(a b c) +(a +(b c)).
}}}

Язык Fun предоставляет возможность создавать рекурсивные функции:

{{{
fun fibb(n)
	if (<(n 2) 
		1
		+(fibb(-(n 1)) fibb(-(n 2)))
	).

fun fact(n) 
	if(=(n 1) 
		1 
		*(fact(-(n 1)) n)
	).
}}}

Еще раз продемонстрировать ленивость языка Fun можно определив такую функцию:
{{{
fun infinity infinity.

fun testLazy(x)
	if(>(x 0) 1 infinity).
	
testLazy(1).
-> 1
}}}

Определенную пользователем функцию можно использовать где угодно ниже определения этой функции. Таким образом такая программа будет некорректной:
{{{
one().

fun one() 1.
}}}

= Типы данных =
[DataTypes Описание типов данных.]

= Лексика =
Как видно из определения грамматики, в языке Fun есть не так много лексем:
  * скобки `(`, `)`;
  * точка `.`;
  * и произвольное имя, не содержащее в себе пробельных символов и символов, составляющих перечисленные выше лексемы.

Между лексемами может быть произвольное количество пробельных символов, которые не влияют на выполнение программы.
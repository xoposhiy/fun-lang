#summary Спецификация языка Fun
#labels Phase-Requirements

== Funny ==

У языка Fun есть одно важное простейшее подмножество Funny, с которого логично начать описание языка.

Грамматика языка Fun состоит всего из двух правил вывода:
{{{
FunCall -> NAME [ '(' FunCall* ')' ]
FunDef  -> fun NAME ['(' NAME* ')'] FunCall
}}}
Первое правило определяет подмножество Funny, позволяющего лишь вычислять функции, являющиеся композицией стандартных, встроенных в язык функций.

Вот примеры корректных программ на Funny и результат выполнения каждой из программ:
{{{
+(2 2)
-> 4

=(4 +(2 2))
-> true

if(>(+(2 2) 3) 
  1
  0
)
-> 1
}}}

Язык Funny лишён возможности инфиксной записи арифметических выражений. Вместо этого все арифметические операции представлены в виде функций. Так, '+', '=', '<' — это имена встроенных функций.

Язык Funny — это ленивый язык. Функция будет вычислена только в том случае, если её значение понадобилось. Благодаря этому свойству, конструкцию if удалось реализовать в виде встроенной функции от трёх аргументов: булева выражения, и двух веток, которые будут вычисляться, если булево выражение соответственно истинно или ложно.

== Fun ==
Второе правило вывода грамматики Fun открывает возможность определять новые функции:

{{{
FunDef  -> fun NAME ['(' NAME* ')'] FunCall
}}}

Вот примеры таких определений:

{{{
fun id(x) x

fun inc(x) +(x 1)

fun sum(a b c) +(a +(b c))
}}}

Язык Fun даёт возможность создавать рекурсивные функции:

{{{
fun fibb(n)
	if (<(n 2) 
		1
		+(fibb(-(n 1)) fibb(-(n 2)))
	)

fun fact(n) 
	if(=(n 1) 
		1 
		*(fact(-(n 1)) n)
	)
}}}

Ещё раз продемонстрировать ленивость языка Fun можно определив такую функцию:
{{{
fun infinity infinity

fun testLazy(x)
	if(>(x 0) 1 infinity)
	
testLazy(1)
-> 1
}}}

== Типы данных ==
*TODO*

== Встроенные ==
*TODO*